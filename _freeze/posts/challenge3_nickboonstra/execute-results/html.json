{
  "hash": "088521edcd7790ae3d0cbfcc0e210648",
  "result": {
    "markdown": "---\ntitle: \"Nick Boonstra Challenge 3\"\nauthor: \"Nick Boonstra\"\ndesription: \"Tidy Data: Pivoting\"\ndate: \"08/17/2022\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - challenge_3\n  - boonstra\n  - week_1\n---\n\n\n## Introduction\n\nIn this challenge, I will be tackling the notorious Australian Marriage Data set!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(readxl)\n\nknitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)\n```\n:::\n\n\n## Reading In\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozzie <- read_excel(\"_data/australian_marriage_law_postal_survey_2017_-_response_final.xls\",\n                   sheet = 3,\n                   skip = 7,\n                   col_names=c(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"))\n```\n:::\n\n\n### Description of Data\n\nAccording to the Australian Bureau of Statistics, these data record the results of a postal survey distributed to eligible Australians asking their opinion on whether or not the law should be changed to allow same-sex couples to marry.\n\nThis data set comes in *messy*. There are three sheets in the .xls file, which can make things a bit tricky, but the actual data live in the third sheet. The sheet has useless header rows that may be somewhat helpful to a human looking over the spreadsheet, but which give R a hard time; I skipped the first 7 rows when reading in the data, keeping an untouched copy of the spreadsheet open separately so I could keep track of what each column corresponded to. Rather than let R assume (or fill in) the header names, I gave the sixteen columns alphabetical names, from \"a\" to \"p\"; I assume there exists a more efficient way to solve this naming problem, but here we are.\n\n## Anticipating the End Result\n\nIn order for data to be considered \"tidy,\" it must meet three criteria:\n\n-   Each column contains values of one variable;\n-   Each row contains values for one observation; and,\n-   Each cell contains one value.\n\nThe original spreadsheet breaks the data down into valid and invalid responses, with valid responses being subdivided into \"Yes\" and \"No\" responses, and each response type being given two values: the number of respondents providing this response, and the percent value of that number of respondents within the given unit (i.e. parliamentary division, state/federal territory, Commonwealth).\n\nThe variable of note in this data set is the number of respondents for each response type, with there being a total of four unique response types (i.e. \"Yes,\" \"No,\" an invalid response, and a non-response). The tidy-compliant of this data set will have a single column recording number of respondents, and another recording response type. Each division will appear four times, one for each response type. As such, a tidy-compliant \"observation\" in this data set is a division-response type, such as Greenway-Yes or Batman-No response.\n\nBeyond the strict definition of tidy-compliance, there are a number of extraneous columns in this data set. The percent values, for example, are completely unnecessary, since these can be extrapolated from the raw response numbers at any point. The column counting the total number of valid responses is also unnecessary, because it double-counts the \"Yes\" and \"No\" responses, and a simple valid/invalid dummy variable can easily be introduced later if this information is still necessary. Lastly, the empty column dividing the valid and total responses is obviously unnecessary.\n\nThis means that the tidy-compliant version of these data will, upon initial transformation, have just three columns: division, response type, and number of respondents. Since the values for response type will all be character-type, I will also create a fourth column assigning numerical categorical values to the four response types.\n\n## Tidy transformations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozzie <- ozzie %>% \n  pivot_longer(\n    cols = c(\n      \"b\", # YES\n      \"d\", # NO\n      \"k\", # UNCLEAR\n      \"m\" # NON-RESPONDING\n    ),\n    values_to = \"num_respondents\",\n    names_to = \"response_type\"\n  )\n\nozzie <- ozzie %>% \n  select(-c(c:p)) %>% \n  rename(division = a) %>% \n  mutate(response_type = case_when(\n    response_type == \"b\" ~ \"Yes\",\n    response_type == \"d\" ~ \"No\",\n    response_type == \"k\" ~ \"Unclear\",\n    response_type == \"m\" ~ \"No response\"\n  )) %>% \n  mutate(response_type_code = case_when(\n    response_type == \"Yes\" ~ 1,\n    response_type == \"No\" ~ 2,\n    response_type == \"Unclear\" ~ 3,\n    response_type == \"No response\" ~ 4\n  ))\n\nozzie\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 736 × 4\n   division                  response_type num_respondents response_type_code\n   <chr>                     <chr>                   <dbl>              <dbl>\n 1 New South Wales Divisions Yes                        NA                  1\n 2 New South Wales Divisions No                         NA                  2\n 3 New South Wales Divisions Unclear                    NA                  3\n 4 New South Wales Divisions No response                NA                  4\n 5 Banks                     Yes                     37736                  1\n 6 Banks                     No                      46343                  2\n 7 Banks                     Unclear                   247                  3\n 8 Banks                     No response             20928                  4\n 9 Barton                    Yes                     37153                  1\n10 Barton                    No                      47984                  2\n# … with 726 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n\nVoila! Looks much better already.\n\nAs an aside, we can create that valid/invalid dummy variable that was mentioned earlier:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozzie <- ozzie %>% # dummy\n  mutate(valid = case_when(\n    response_type_code < 3 ~ 1,\n    T ~ 0\n  ))\n\nozzie\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 736 × 5\n   division                  response_type num_respondents response_type…¹ valid\n   <chr>                     <chr>                   <dbl>           <dbl> <dbl>\n 1 New South Wales Divisions Yes                        NA               1     1\n 2 New South Wales Divisions No                         NA               2     1\n 3 New South Wales Divisions Unclear                    NA               3     0\n 4 New South Wales Divisions No response                NA               4     0\n 5 Banks                     Yes                     37736               1     1\n 6 Banks                     No                      46343               2     1\n 7 Banks                     Unclear                   247               3     0\n 8 Banks                     No response             20928               4     0\n 9 Barton                    Yes                     37153               1     1\n10 Barton                    No                      47984               2     1\n# … with 726 more rows, and abbreviated variable name ¹​response_type_code\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n\nThis can help when it comes to grouping and visualizing these data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozzie %>% \n  group_by(response_type_code) %>% \n  summarise(\"Mean number of respondents\"=mean(num_respondents,na.rm=T))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  response_type_code `Mean number of respondents`\n               <dbl>                        <dbl>\n1                  1                      147495.\n2                  2                       91962.\n3                  3                         692.\n4                  4                       61854.\n```\n:::\n\n```{.r .cell-code}\nozzie %>% \n  group_by(valid) %>% \n  summarise(\"Mean number of respondents\"=mean(num_respondents,na.rm=T))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  valid `Mean number of respondents`\n  <dbl>                        <dbl>\n1     0                       31273.\n2     1                      119729.\n```\n:::\n:::\n\n\n### Shortcomings in Transformation\n\nDespite these transformations, this data frame leaves a lot to be desired at this point. There are still a number of useless rows, some of which served as headers for the different federal divisions, and some of which are just empty for visual division of the original spreadsheet. These rows, as well as other \"footnote\" rows at the bottom of the df, still need to be deleted. Before doing that, though, I would like to be able to pivot_wider (or something to that effect) to create a column that tracks which state or federal territory each division lives in. However, at present I can't figure out how to do that given the data set as it is.\n",
    "supporting": [
      "challenge3_nickboonstra_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}