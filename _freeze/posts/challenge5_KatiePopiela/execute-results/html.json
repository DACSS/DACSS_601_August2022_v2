{
  "hash": "347f56c37ccb435618b2cd4d71e2077b",
  "result": {
    "markdown": "---\ntitle: \"Challenge5_KatiePopiela\"\neditor: visual\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(ggplot2)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages\n───────────────────────────────────────\ntidyverse 1.3.2 ──\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ tibble  3.1.8     ✔ stringr 1.4.0\n✔ tidyr   1.2.0     ✔ forcats 0.5.1\n✔ purrr   0.3.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nlibrary(plyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n------------------------------------------------------------------------------\nYou have loaded plyr after dplyr - this is likely to cause problems.\nIf you need functions from both plyr and dplyr, please load plyr first, then dplyr:\nlibrary(plyr); library(dplyr)\n------------------------------------------------------------------------------\n\nAttaching package: 'plyr'\n\nThe following object is masked from 'package:purrr':\n\n    compact\n\nThe following objects are masked from 'package:dplyr':\n\n    arrange, count, desc, failwith, id, mutate, rename, summarise,\n    summarize\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidyr)\nlibrary(scales)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'scales'\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n```\n:::\n:::\n\n\n### 1) read in a data set, and describe the data set using both words and any supporting information (e.g., tables, etc)\n\n### 2) tidy data (as needed, including sanity checks)\n\n### 3) mutate variables as needed (including sanity checks)\n\n### 4) create at least two univariate visualizations. Try to make them \"publication\" ready. Explain why you choose the specific graph type.\n\n### 5) Create at least one bivariate visualization. Try to make them \"publication\" ready. Explain why you choose the specific graph type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naustralian_marriage_survey_responses <- read.csv(\"_data/australian_marriage_tidy.csv\")\nview(australian_marriage_survey_responses)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#This data set is a record of Australians' support or non-support of a new marriage law (don't know what it is), and the responses are organized by the state/province the respondents reside in.\n\n#I'm going to try and break the data down and show the range of \"yes\" votes per territory as well as that for \"no\".\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(australian_marriage_survey_responses)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"territory\" \"resp\"      \"count\"     \"percent\"  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#These column names are pretty straightforward so I'm not going to rename them. \n\n#Update: R kept getting confused by the column \"count\" so I'm renaming it to \"num_responses\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(australian_marriage_survey_responses)[names(australian_marriage_survey_responses) == 'count'] <- 'num_responses'\n\nnames(australian_marriage_survey_responses)[names(australian_marriage_survey_responses) == 'yn_responses'] <- 'resp'\n\ncolnames(australian_marriage_survey_responses)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"territory\"     \"resp\"          \"num_responses\" \"percent\"      \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(australian_marriage_survey_responses, aes(x=num_responses,y=territory,color=resp)) +geom_point() + xlab(\"Number of Responses\") + ylab(\"Territory\")\n```\n\n::: {.cell-output-display}\n![](challenge5_KatiePopiela_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Above is my bivariate visual. For whatever reason it just wouldn't let me change the label for the color/fill. I can include it in the code, it just won't change it.\n\n#So above, the y-axis is the different territories respondents are from and the x-axis is the number of responses. I wanted to show (in more easily readable fashion) the number of yes and no responses to this proposed-law for each state. As you can see, the red dots are \"no\" and the blue are \"yes.\" Since it'd be hard to get the exact number of \"yes\" and \"no\" responses from the points alone, I'm going to pick one territory as an example and present the values as a univariate visual.\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\naustralian_survey_response_1 <- australian_marriage_survey_responses %>%\n  select(territory, num_responses, resp) %>%\n  filter(territory == \"Victoria\") %>%\n  view()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(australian_survey_response_1, aes(y=num_responses,x=resp)) + geom_bar(position=\"stack\",stat=\"identity\") + labs(x=\"Responses, Y/N\", y=\"Number of Responses\") \n```\n\n::: {.cell-output-display}\n![](challenge5_KatiePopiela_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#Below is a simple bar graph showing the \"yes\" and \"no\" votes in the territory of Victoria. The majority of respondents voted \"yes.\" \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\naustralian_survey_response_2 <- australian_marriage_survey_responses %>%\n  mutate(percent = num_responses/sum(num_responses)*100) %>%\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: <text>:3:0: unexpected end of input\n1: australian_survey_response_2 <- australian_marriage_survey_responses %>%\n2:   mutate(percent = num_responses/sum(num_responses)*100) %>%\n  ^\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(australian_survey_response_2, aes(fill=resp,x=territory,y=percent))+geom_bar(position = \"stack\",stat=\"identity\") + ylab(\"Percentage of Responses\") + xlab(\"Territory\") + labs(fill= \"Responses\") + coord_flip() \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in ggplot(australian_survey_response_2, aes(fill = resp, x = territory, : object 'australian_survey_response_2' not found\n```\n:::\n\n```{.r .cell-code}\n#In order to make this graph, I first added a column, using mutate(), which converted the vote counts (for \"yes\" and \"no\") into percentages. Then I created a percentage bar graph, made the response variable the fill color(s), and stacked the percentages. This graph is useful as a quick overview of how many people voted \"yes\" or \"no\" in this postal survey, and unlike the very first graph, the figures are much more easily gathered in this format than with a point chart \n```\n:::\n",
    "supporting": [
      "challenge5_KatiePopiela_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}